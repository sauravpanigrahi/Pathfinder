{
  "questions": [
    {
      "id": 1,
      "category": "Arrays",
      "difficulty": "Easy",
      "question": "Write a function to find the maximum element in an array.",
      "answer": "function findMax(arr) {\n  if (arr.length === 0) return null;\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n}\n// Alternative: return Math.max(...arr);",
      "tags": ["arrays", "iteration"]
    },
    {
      "id": 2,
      "category": "Arrays",
      "difficulty": "Easy",
      "question": "Write a function to reverse an array in place.",
      "answer": "function reverseArray(arr) {\n  let left = 0;\n  let right = arr.length - 1;\n  while (left < right) {\n    [arr[left], arr[right]] = [arr[right], arr[left]];\n    left++;\n    right--;\n  }\n  return arr;\n}",
      "tags": ["arrays", "two-pointers"]
    },
    {
      "id": 3,
      "category": "Arrays",
      "difficulty": "Medium",
      "question": "Find two numbers in an array that sum to a target value.",
      "answer": "function twoSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}\n// Time: O(n), Space: O(n)",
      "tags": ["arrays", "hash-map", "two-sum"]
    },
    {
      "id": 4,
      "category": "Arrays",
      "difficulty": "Medium",
      "question": "Remove duplicates from a sorted array in place.",
      "answer": "function removeDuplicates(nums) {\n  if (nums.length === 0) return 0;\n  let i = 0;\n  for (let j = 1; j < nums.length; j++) {\n    if (nums[j] !== nums[i]) {\n      i++;\n      nums[i] = nums[j];\n    }\n  }\n  return i + 1;\n}\n// Time: O(n), Space: O(1)",
      "tags": ["arrays", "two-pointers"]
    },
    {
      "id": 5,
      "category": "Arrays",
      "difficulty": "Medium",
      "question": "Rotate an array to the right by k steps.",
      "answer": "function rotate(nums, k) {\n  k = k % nums.length;\n  reverse(nums, 0, nums.length - 1);\n  reverse(nums, 0, k - 1);\n  reverse(nums, k, nums.length - 1);\n}\n\nfunction reverse(arr, start, end) {\n  while (start < end) {\n    [arr[start], arr[end]] = [arr[end], arr[start]];\n    start++;\n    end--;\n  }\n}\n// Time: O(n), Space: O(1)",
      "tags": ["arrays", "rotation"]
    },
    {
      "id": 6,
      "category": "Arrays",
      "difficulty": "Hard",
      "question": "Find the maximum subarray sum (Kadane's Algorithm).",
      "answer": "function maxSubArray(nums) {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n  \n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}\n// Time: O(n), Space: O(1)",
      "tags": ["arrays", "dynamic-programming", "kadane"]
    },
    {
      "id": 7,
      "category": "Arrays",
      "difficulty": "Medium",
      "question": "Find the missing number in an array of 1 to n.",
      "answer": "function missingNumber(nums) {\n  const n = nums.length;\n  const expectedSum = (n * (n + 1)) / 2;\n  const actualSum = nums.reduce((sum, num) => sum + num, 0);\n  return expectedSum - actualSum;\n}\n// Alternative: Use XOR for bit manipulation\n// Time: O(n), Space: O(1)",
      "tags": ["arrays", "math"]
    },
    {
      "id": 8,
      "category": "Arrays",
      "difficulty": "Medium",
      "question": "Move all zeros to the end of an array while maintaining order.",
      "answer": "function moveZeros(nums) {\n  let nonZeroIndex = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      [nums[nonZeroIndex], nums[i]] = [nums[i], nums[nonZeroIndex]];\n      nonZeroIndex++;\n    }\n  }\n  return nums;\n}\n// Time: O(n), Space: O(1)",
      "tags": ["arrays", "two-pointers"]
    },
    {
      "id": 9,
      "category": "Arrays",
      "difficulty": "Easy",
      "question": "Check if an array contains duplicate elements.",
      "answer": "function containsDuplicate(nums) {\n  const seen = new Set();\n  for (let num of nums) {\n    if (seen.has(num)) {\n      return true;\n    }\n    seen.add(num);\n  }\n  return false;\n}\n// Alternative: return new Set(nums).size !== nums.length;\n// Time: O(n), Space: O(n)",
      "tags": ["arrays", "hash-set"]
    },
    {
      "id": 10,
      "category": "Arrays",
      "difficulty": "Medium",
      "question": "Find the intersection of two arrays.",
      "answer": "function intersection(nums1, nums2) {\n  const set1 = new Set(nums1);\n  const result = new Set();\n  \n  for (let num of nums2) {\n    if (set1.has(num)) {\n      result.add(num);\n    }\n  }\n  return Array.from(result);\n}\n// Time: O(n + m), Space: O(n)",
      "tags": ["arrays", "hash-set"]
    },
    {
      "id": 11,
      "category": "Strings",
      "difficulty": "Easy",
      "question": "Reverse a string.",
      "answer": "function reverseString(s) {\n  return s.split('').reverse().join('');\n}\n\n// In-place for array:\nfunction reverseStringArray(s) {\n  let left = 0, right = s.length - 1;\n  while (left < right) {\n    [s[left], s[right]] = [s[right], s[left]];\n    left++;\n    right--;\n  }\n}\n// Time: O(n), Space: O(1) for in-place",
      "tags": ["strings", "two-pointers"]
    },
    {
      "id": 12,
      "category": "Strings",
      "difficulty": "Easy",
      "question": "Check if a string is a palindrome.",
      "answer": "function isPalindrome(s) {\n  s = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n  let left = 0, right = s.length - 1;\n  \n  while (left < right) {\n    if (s[left] !== s[right]) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;\n}\n// Time: O(n), Space: O(1)",
      "tags": ["strings", "palindrome"]
    },
    {
      "id": 13,
      "category": "Strings",
      "difficulty": "Medium",
      "question": "Find the first non-repeating character in a string.",
      "answer": "function firstUniqChar(s) {\n  const charCount = {};\n  \n  for (let char of s) {\n    charCount[char] = (charCount[char] || 0) + 1;\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    if (charCount[s[i]] === 1) {\n      return i;\n    }\n  }\n  return -1;\n}\n// Time: O(n), Space: O(1) - limited charset",
      "tags": ["strings", "hash-map"]
    },
    {
      "id": 14,
      "category": "Strings",
      "difficulty": "Medium",
      "question": "Check if two strings are anagrams.",
      "answer": "function isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  \n  const count = {};\n  for (let char of s) {\n    count[char] = (count[char] || 0) + 1;\n  }\n  \n  for (let char of t) {\n    if (!count[char]) return false;\n    count[char]--;\n  }\n  return true;\n}\n// Time: O(n), Space: O(1)",
      "tags": ["strings", "anagram"]
    },
    {
      "id": 15,
      "category": "Strings",
      "difficulty": "Easy",
      "question": "Count the number of vowels in a string.",
      "answer": "function countVowels(s) {\n  const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n  let count = 0;\n  \n  for (let char of s) {\n    if (vowels.has(char)) {\n      count++;\n    }\n  }\n  return count;\n}\n// Alternative: s.match(/[aeiou]/gi)?.length || 0\n// Time: O(n), Space: O(1)",
      "tags": ["strings", "counting"]
    },
    {
      "id": 16,
      "category": "Strings",
      "difficulty": "Medium",
      "question": "Implement string compression (e.g., 'aabcccccaaa' -> 'a2b1c5a3').",
      "answer": "function compress(s) {\n  let result = '';\n  let count = 1;\n  \n  for (let i = 1; i <= s.length; i++) {\n    if (s[i] === s[i-1]) {\n      count++;\n    } else {\n      result += s[i-1] + count;\n      count = 1;\n    }\n  }\n  return result.length < s.length ? result : s;\n}\n// Time: O(n), Space: O(n)",
      "tags": ["strings", "compression"]
    },
    {
      "id": 17,
      "category": "Strings",
      "difficulty": "Medium",
      "question": "Find the longest substring without repeating characters.",
      "answer": "function lengthOfLongestSubstring(s) {\n  const seen = new Map();\n  let maxLen = 0, start = 0;\n  \n  for (let end = 0; end < s.length; end++) {\n    if (seen.has(s[end])) {\n      start = Math.max(start, seen.get(s[end]) + 1);\n    }\n    seen.set(s[end], end);\n    maxLen = Math.max(maxLen, end - start + 1);\n  }\n  return maxLen;\n}\n// Time: O(n), Space: O(min(n,m))",
      "tags": ["strings", "sliding-window"]
    },
    {
      "id": 18,
      "category": "Strings",
      "difficulty": "Easy",
      "question": "Convert a string to title case.",
      "answer": "function toTitleCase(s) {\n  return s.toLowerCase()\n    .split(' ')\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(' ');\n}\n// Example: 'hello world' -> 'Hello World'\n// Time: O(n), Space: O(n)",
      "tags": ["strings", "formatting"]
    },
    {
      "id": 19,
      "category": "Strings",
      "difficulty": "Medium",
      "question": "Check if one string is a rotation of another.",
      "answer": "function isRotation(s1, s2) {\n  if (s1.length !== s2.length) return false;\n  return (s1 + s1).includes(s2);\n}\n// Example: 'waterbottle' is rotation of 'erbottlewat'\n// Time: O(n), Space: O(n)",
      "tags": ["strings", "rotation"]
    },
    {
      "id": 20,
      "category": "Strings",
      "difficulty": "Hard",
      "question": "Find all permutations of a string.",
      "answer": "function permute(s) {\n  const result = [];\n  \n  function backtrack(current, remaining) {\n    if (remaining.length === 0) {\n      result.push(current);\n      return;\n    }\n    \n    for (let i = 0; i < remaining.length; i++) {\n      backtrack(\n        current + remaining[i],\n        remaining.slice(0, i) + remaining.slice(i + 1)\n      );\n    }\n  }\n  \n  backtrack('', s);\n  return result;\n}\n// Time: O(n!), Space: O(n!)",
      "tags": ["strings", "backtracking", "recursion"]
    },
    {
      "id": 21,
      "category": "Linked Lists",
      "difficulty": "Easy",
      "question": "Reverse a singly linked list.",
      "answer": "function reverseList(head) {\n  let prev = null;\n  let current = head;\n  \n  while (current !== null) {\n    let nextTemp = current.next;\n    current.next = prev;\n    prev = current;\n    current = nextTemp;\n  }\n  return prev;\n}\n// Time: O(n), Space: O(1)",
      "tags": ["linked-list", "reversal"]
    },
    {
      "id": 22,
      "category": "Linked Lists",
      "difficulty": "Easy",
      "question": "Detect if a linked list has a cycle.",
      "answer": "function hasCycle(head) {\n  if (!head || !head.next) return false;\n  \n  let slow = head;\n  let fast = head.next;\n  \n  while (slow !== fast) {\n    if (!fast || !fast.next) return false;\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return true;\n}\n// Floyd's Cycle Detection\n// Time: O(n), Space: O(1)",
      "tags": ["linked-list", "two-pointers", "cycle"]
    },
    {
      "id": 23,
      "category": "Linked Lists",
      "difficulty": "Medium",
      "question": "Find the middle node of a linked list.",
      "answer": "function middleNode(head) {\n  let slow = head;\n  let fast = head;\n  \n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow;\n}\n// Time: O(n), Space: O(1)",
      "tags": ["linked-list", "two-pointers"]
    },
    {
      "id": 24,
      "category": "Linked Lists",
      "difficulty": "Medium",
      "question": "Merge two sorted linked lists.",
      "answer": "function mergeTwoLists(l1, l2) {\n  const dummy = { val: 0, next: null };\n  let current = dummy;\n  \n  while (l1 && l2) {\n    if (l1.val < l2.val) {\n      current.next = l1;\n      l1 = l1.next;\n    } else {\n      current.next = l2;\n      l2 = l2.next;\n    }\n    current = current.next;\n  }\n  current.next = l1 || l2;\n  return dummy.next;\n}\n// Time: O(n+m), Space: O(1)",
      "tags": ["linked-list", "merge"]
    },
    {
      "id": 25,
      "category": "Linked Lists",
      "difficulty": "Medium",
      "question": "Remove nth node from end of linked list.",
      "answer": "function removeNthFromEnd(head, n) {\n  const dummy = { val: 0, next: head };\n  let first = dummy;\n  let second = dummy;\n  \n  for (let i = 0; i <= n; i++) {\n    first = first.next;\n  }\n  \n  while (first) {\n    first = first.next;\n    second = second.next;\n  }\n  \n  second.next = second.next.next;\n  return dummy.next;\n}\n// Time: O(n), Space: O(1)",
      "tags": ["linked-list", "two-pointers"]
    },
    {
      "id": 26,
      "category": "Linked Lists",
      "difficulty": "Easy",
      "question": "Delete a node from linked list (given only access to that node).",
      "answer": "function deleteNode(node) {\n  node.val = node.next.val;\n  node.next = node.next.next;\n}\n// Note: Only works if node is not the last node\n// Time: O(1), Space: O(1)",
      "tags": ["linked-list", "deletion"]
    },
    {
      "id": 27,
      "category": "Linked Lists",
      "difficulty": "Medium",
      "question": "Check if a linked list is a palindrome.",
      "answer": "function isPalindrome(head) {\n  if (!head || !head.next) return true;\n  \n  // Find middle\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  \n  // Reverse second half\n  let prev = null;\n  while (slow) {\n    let temp = slow.next;\n    slow.next = prev;\n    prev = slow;\n    slow = temp;\n  }\n  \n  // Compare\n  let left = head, right = prev;\n  while (right) {\n    if (left.val !== right.val) return false;\n    left = left.next;\n    right = right.next;\n  }\n  return true;\n}\n// Time: O(n), Space: O(1)",
      "tags": ["linked-list", "palindrome"]
    },
    {
      "id": 28,
      "category": "Linked Lists",
      "difficulty": "Hard",
      "question": "Find the intersection point of two linked lists.",
      "answer": "function getIntersectionNode(headA, headB) {\n  if (!headA || !headB) return null;\n  \n  let a = headA, b = headB;\n  \n  while (a !== b) {\n    a = a ? a.next : headB;\n    b = b ? b.next : headA;\n  }\n  return a;\n}\n// Time: O(n+m), Space: O(1)",
      "tags": ["linked-list", "intersection"]
    },
    {
      "id": 29,
      "category": "Linked Lists",
      "difficulty": "Medium",
      "question": "Add two numbers represented by linked lists.",
      "answer": "function addTwoNumbers(l1, l2) {\n  const dummy = { val: 0, next: null };\n  let current = dummy;\n  let carry = 0;\n  \n  while (l1 || l2 || carry) {\n    const sum = (l1?.val || 0) + (l2?.val || 0) + carry;\n    carry = Math.floor(sum / 10);\n    current.next = { val: sum % 10, next: null };\n    current = current.next;\n    l1 = l1?.next;\n    l2 = l2?.next;\n  }\n  return dummy.next;\n}\n// Time: O(max(n,m)), Space: O(max(n,m))",
      "tags": ["linked-list", "math"]
    },
    {
      "id": 30,
      "category": "Linked Lists",
      "difficulty": "Medium",
      "question": "Flatten a multilevel doubly linked list.",
      "answer": "function flatten(head) {\n  if (!head) return null;\n  \n  const stack = [];\n  let current = head;\n  \n  while (current) {\n    if (current.child) {\n      if (current.next) stack.push(current.next);\n      current.next = current.child;\n      current.next.prev = current;\n      current.child = null;\n    }\n    \n    if (!current.next && stack.length) {\n      current.next = stack.pop();\n      current.next.prev = current;\n    }\n    current = current.next;\n  }\n  return head;\n}\n// Time: O(n), Space: O(n)",
      "tags": ["linked-list", "stack"]
    },
    {
      "id": 31,
      "category": "Trees",
      "difficulty": "Easy",
      "question": "Find the maximum depth of a binary tree.",
      "answer": "function maxDepth(root) {\n  if (!root) return 0;\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n\n// Iterative BFS:\nfunction maxDepthBFS(root) {\n  if (!root) return 0;\n  const queue = [[root, 1]];\n  let maxDepth = 0;\n  \n  while (queue.length) {\n    const [node, depth] = queue.shift();\n    maxDepth = Math.max(maxDepth, depth);\n    if (node.left) queue.push([node.left, depth + 1]);\n    if (node.right) queue.push([node.right, depth + 1]);\n  }\n  return maxDepth;\n}\n// Time: O(n), Space: O(h)",
      "tags": ["trees", "recursion", "dfs"]
    },
    {
      "id": 32,
      "category": "Trees",
      "difficulty": "Easy",
      "question": "Check if a binary tree is balanced.",
      "answer": "function isBalanced(root) {\n  function height(node) {\n    if (!node) return 0;\n    \n    const leftHeight = height(node.left);\n    if (leftHeight === -1) return -1;\n    \n    const rightHeight = height(node.right);\n    if (rightHeight === -1) return -1;\n    \n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n  \n  return height(root) !== -1;\n}\n// Time: O(n), Space: O(h)",
      "tags": ["trees", "recursion"]
    },
    {
      "id": 33,
      "category": "Trees",
      "difficulty": "Medium",
      "question": "Perform inorder traversal of a binary tree (iterative).",
      "answer": "function inorderTraversal(root) {\n  const result = [];\n  const stack = [];\n  let current = root;\n  \n  while (current || stack.length) {\n    while (current) {\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop();\n    result.push(current.val);\n    current = current.right;\n  }\n  return result;\n}\n// Time: O(n), Space: O(h)",
      "tags": ["trees", "traversal", "stack"]
    },
    {
      "id": 34,
      "category": "Trees",
      "difficulty": "Easy",
      "question": "Find the lowest common ancestor of two nodes in a BST.",
      "answer": "function lowestCommonAncestor(root, p, q) {\n  while (root) {\n    if (p.val < root.val && q.val < root.val) {\n      root = root.left;\n    } else if (p.val > root.val && q.val > root.val) {\n      root = root.right;\n    } else {\n      return root;\n    }\n  }\n  return null;\n}\n// Time: O(h), Space: O(1)",
      "tags": ["trees", "bst", "lca"]
    },
    {
      "id": 35,
      "category": "Trees",
      "difficulty": "Medium",
      "question": "Validate if a binary tree is a valid BST.",
      "answer": "function isValidBST(root) {\n  function validate(node, min, max) {\n    if (!node) return true;\n    \n    if (node.val <= min || node.val >= max) {\n      return false;\n    }\n    \n    return validate(node.left, min, node.val) && \n           validate(node.right, node.val, max);\n  }\n  \n  return validate(root, -Infinity, Infinity);\n}\n// Time: O(n), Space: O(h)",
      "tags": ["trees", "bst", "validation"]
    },
    {
      "id": 36,
      "category": "Trees",
      "difficulty": "Medium",
      "question": "Level order traversal of a binary tree.",
      "answer": "function levelOrder(root) {\n  if (!root) return [];\n  \n  const result = [];\n  const queue = [root];\n  \n  while (queue.length) {\n    const levelSize = queue.length;\n    const currentLevel = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      currentLevel.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    result.push(currentLevel);\n  }\n  return result;\n}\n// Time: O(n), Space: O(n)",
      "tags": ["trees", "bfs", "traversal"]
    },
    {
      "id": 37,
      "category": "Trees",
      "difficulty": "Easy",
      "question": "Check if two binary trees are identical.",
      "answer": "function isSameTree(p, q) {\n  if (!p && !q) return true;\n  if (!p || !q) return false;\n  if (p.val !== q.val) return false;\n  \n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n// Time: O(n), Space: O(h)",
      "tags": ["trees", "recursion"]
    },
    {
      "id": 38,
      "category": "Trees",
      "difficulty": "Medium",
      "question": "Find the diameter of a binary tree.",
      "answer": "function diameterOfBinaryTree(root) {\n  let diameter = 0;\n  \n  function height(node) {\n    if (!node) return 0;\n    \n    const leftHeight = height(node.left);\n    const rightHeight = height(node.right);\n    \n    diameter = Math.max(diameter, leftHeight + rightHeight);\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n  \n  height(root);\n  return diameter;\n}\n// Time: O(n), Space: O(h)",
      "tags": ["trees", "recursion"]
    },
    {
      "id": 39,
      "category": "Trees",
      "difficulty": "Medium",
      "question": "Convert a sorted array to a balanced BST.",
      "answer": "function sortedArrayToBST(nums) {\n  function buildBST(left, right) {\n    if (left > right) return null;\n    \n    const mid = Math.floor((left + right) / 2);\n    const node = { val: nums[mid], left: null, right: null };\n    \n    node.left = buildBST(left, mid - 1);\n    node.right = buildBST(mid + 1, right);\n    return node;\n  }\n  \n  return buildBST(0, nums.length - 1);\n}\n// Time: O(n), Space: O(log n)",
      "tags": ["trees", "bst", "recursion"]
    },
    {
      "id": 40,
      "category": "Trees",
      "difficulty": "Hard",
      "question": "Serialize and deserialize a binary tree.",
      "answer": "function serialize(root) {\n  if (!root) return 'null';\n  return root.val + ',' + serialize(root.left) + ',' + serialize(root.right);\n}\n\nfunction deserialize(data) {\n  const values = data.split(',');\n  let index = 0;\n  \n  function build() {\n    if (values[index] === 'null') {\n      index++;\n      return null;\n    }\n    \n    const node = { val: parseInt(values[index++]), left: null, right: null };\n    node.left = build();\n    node.right = build();\n    return node;\n  }\n  \n  return build();\n}\n// Time: O(n), Space: O(n)",
      "tags": ["trees", "serialization"]
    },
    {
    "id": 41,
    "category": "Stacks",
    "difficulty": "Easy",
    "question": "Validate parentheses in a string containing '()[]{}'.",
    "answer": "function isValid(s) {\n  const stack = [];\n  const map = { ')': '(', ']': '[', '}': '{' };\n  for (let ch of s) {\n    if (ch === '(' || ch === '[' || ch === '{') {\n      stack.push(ch);\n    } else {\n      if (stack.pop() !== map[ch]) return false;\n    }\n  }\n  return stack.length === 0;\n}\n// Time: O(n), Space: O(n)",
    "tags": ["stack", "parentheses", "strings"]
  },
  {
    "id": 42,
    "category": "Stacks",
    "difficulty": "Medium",
    "question": "Evaluate a Reverse Polish Notation (RPN) expression.",
    "answer": "function evalRPN(tokens) {\n  const stack = [];\n  const ops = {\n    '+': (a, b) => a + b,\n    '-': (a, b) => a - b,\n    '*': (a, b) => a * b,\n    '/': (a, b) => (a / b) | 0\n  };\n  for (let t of tokens) {\n    if (t in ops) {\n      const b = stack.pop();\n      const a = stack.pop();\n      stack.push(ops[t](a, b));\n    } else {\n      stack.push(parseInt(t, 10));\n    }\n  }\n  return stack.pop();\n}\n// Time: O(n), Space: O(n)",
    "tags": ["stack", "rpn", "math"]
  },
  {
    "id": 43,
    "category": "Queues",
    "difficulty": "Medium",
    "question": "Implement a queue using two stacks.",
    "answer": "class MyQueue {\n  constructor() {\n    this.inStack = [];\n    this.outStack = [];\n  }\n\n  push(x) {\n    this.inStack.push(x);\n  }\n\n  pop() {\n    this.peek();\n    return this.outStack.pop();\n  }\n\n  peek() {\n    if (this.outStack.length === 0) {\n      while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n      }\n    }\n    return this.outStack[this.outStack.length - 1];\n  }\n\n  empty() {\n    return this.inStack.length === 0 && this.outStack.length === 0;\n  }\n}\n// Amortized Time: O(1), Space: O(n)",
    "tags": ["queue", "stack", "design"]
  },
  {
    "id": 44,
    "category": "Heaps",
    "difficulty": "Medium",
    "question": "Find the k-th largest element in an array.",
    "answer": "function findKthLargest(nums, k) {\n  // Min-heap of size k\n  const heap = [];\n  function push(x) {\n    heap.push(x);\n    let i = heap.length - 1;\n    while (i > 0) {\n      const p = (i - 1) >> 1;\n      if (heap[p] <= heap[i]) break;\n      [heap[p], heap[i]] = [heap[i], heap[p]];\n      i = p;\n    }\n  }\n  function pop() {\n    const top = heap[0];\n    const last = heap.pop();\n    if (heap.length) {\n      heap[0] = last;\n      let i = 0;\n      while (true) {\n        let l = 2 * i + 1, r = 2 * i + 2, s = i;\n        if (l < heap.length && heap[l] < heap[s]) s = l;\n        if (r < heap.length && heap[r] < heap[s]) s = r;\n        if (s === i) break;\n        [heap[i], heap[s]] = [heap[s], heap[i]];\n        i = s;\n      }\n    }\n    return top;\n  }\n  for (let n of nums) {\n    push(n);\n    if (heap.length > k) pop();\n  }\n  return heap[0];\n}\n// Time: O(n log k), Space: O(k)",
    "tags": ["heap", "priority-queue", "selection"]
  },
  {
    "id": 45,
    "category": "Graphs",
    "difficulty": "Medium",
    "question": "Detect if an undirected graph contains a cycle using DFS.",
    "answer": "function hasCycleUndirected(n, edges) {\n  const graph = Array.from({ length: n }, () => []);\n  for (let [u, v] of edges) {\n    graph[u].push(v);\n    graph[v].push(u);\n  }\n  const visited = new Array(n).fill(false);\n\n  function dfs(node, parent) {\n    visited[node] = true;\n    for (let nei of graph[node]) {\n      if (!visited[nei]) {\n        if (dfs(nei, node)) return true;\n      } else if (nei !== parent) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  for (let i = 0; i < n; i++) {\n    if (!visited[i] && dfs(i, -1)) return true;\n  }\n  return false;\n}\n// Time: O(n + m), Space: O(n + m)",
    "tags": ["graphs", "dfs", "cycle"]
  },
  {
    "id": 46,
    "category": "Graphs",
    "difficulty": "Medium",
    "question": "Perform BFS on a graph from a given source node and return shortest path lengths (unweighted).",
    "answer": "function bfsShortestPaths(n, edges, src) {\n  const graph = Array.from({ length: n }, () => []);\n  for (let [u, v] of edges) {\n    graph[u].push(v);\n    graph[v].push(u);\n  }\n  const dist = new Array(n).fill(Infinity);\n  const queue = [src];\n  dist[src] = 0;\n\n  while (queue.length) {\n    const node = queue.shift();\n    for (let nei of graph[node]) {\n      if (dist[nei] === Infinity) {\n        dist[nei] = dist[node] + 1;\n        queue.push(nei);\n      }\n    }\n  }\n  return dist;\n}\n// Time: O(n + m), Space: O(n + m)",
    "tags": ["graphs", "bfs", "shortest-path"]
  },
  {
    "id": 47,
    "category": "Dynamic Programming",
    "difficulty": "Easy",
    "question": "Compute the n-th Fibonacci number using dynamic programming.",
    "answer": "function fib(n) {\n  if (n <= 1) return n;\n  let prev2 = 0, prev1 = 1;\n  for (let i = 2; i <= n; i++) {\n    const cur = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = cur;\n  }\n  return prev1;\n}\n// Time: O(n), Space: O(1)",
    "tags": ["dp", "math", "fibonacci"]
  },
  {
    "id": 48,
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "question": "Solve the classic 0/1 Knapsack problem (max value with weight constraint).",
    "answer": "function knapSack(W, weights, values) {\n  const n = weights.length;\n  const dp = Array.from({ length: n + 1 }, () => new Array(W + 1).fill(0));\n  for (let i = 1; i <= n; i++) {\n    for (let w = 0; w <= W; w++) {\n      dp[i][w] = dp[i - 1][w];\n      if (weights[i - 1] <= w) {\n        dp[i][w] = Math.max(\n          dp[i][w],\n          values[i - 1] + dp[i - 1][w - weights[i - 1]]\n        );\n      }\n    }\n  }\n  return dp[n][W];\n}\n// Time: O(nW), Space: O(nW)",
    "tags": ["dp", "knapsack"]
  },
  {
    "id": 49,
    "category": "Searching",
    "difficulty": "Easy",
    "question": "Implement binary search on a sorted array.",
    "answer": "function binarySearch(nums, target) {\n  let left = 0, right = nums.length - 1;\n  while (left <= right) {\n    const mid = left + ((right - left) >> 1);\n    if (nums[mid] === target) return mid;\n    if (nums[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n}\n// Time: O(log n), Space: O(1)",
    "tags": ["binary-search", "arrays"]
  },
  {
    "id": 50,
    "category": "Sorting",
    "difficulty": "Medium",
    "question": "Implement merge sort for an array of numbers.",
    "answer": "function mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = arr.length >> 1;\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0, j = 0;\n  while (i < left.length && j < right.length) {\n    if (left[i] <= right[j]) result.push(left[i++]);\n    else result.push(right[j++]);\n  }\n  while (i < left.length) result.push(left[i++]);\n  while (j < right.length) result.push(right[j++]);\n  return result;\n}\n// Time: O(n log n), Space: O(n)",
    "tags": ["sorting", "merge-sort", "divide-and-conquer"]
  },
  {
    "id": 51,
    "category": "Arrays",
    "difficulty": "Medium",
    "question": "Product of array except self.",
    "answer": "function productExceptSelf(nums) {\n  const n = nums.length;\n  const res = new Array(n).fill(1);\n  let prefix = 1;\n  for (let i = 0; i < n; i++) {\n    res[i] = prefix;\n    prefix *= nums[i];\n  }\n  let suffix = 1;\n  for (let i = n - 1; i >= 0; i--) {\n    res[i] *= suffix;\n    suffix *= nums[i];\n  }\n  return res;\n}\n// Time: O(n), Space: O(1) extra",
    "tags": ["arrays", "prefix-product"]
  },
  {
    "id": 52,
    "category": "Arrays",
    "difficulty": "Medium",
    "question": "Find all triplets that sum to zero (3-sum).",
    "answer": "function threeSum(nums) {\n  nums.sort((a, b) => a - b);\n  const res = [];\n  const n = nums.length;\n  for (let i = 0; i < n - 2; i++) {\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n    let l = i + 1, r = n - 1;\n    while (l < r) {\n      const sum = nums[i] + nums[l] + nums[r];\n      if (sum === 0) {\n        res.push([nums[i], nums[l], nums[r]]);\n        while (l < r && nums[l] === nums[l + 1]) l++;\n        while (l < r && nums[r] === nums[r - 1]) r--;\n        l++; r--;\n      } else if (sum < 0) l++;\n      else r--;\n    }\n  }\n  return res;\n}\n// Time: O(n^2), Space: O(1) extra",
    "tags": ["arrays", "two-pointers", "3-sum"]
  },
  {
    "id": 53,
    "category": "Arrays",
    "difficulty": "Medium",
    "question": "Merge overlapping intervals.",
    "answer": "function mergeIntervals(intervals) {\n  if (!intervals.length) return [];\n  intervals.sort((a, b) => a[0] - b[0]);\n  const res = [intervals[0]];\n  for (let i = 1; i < intervals.length; i++) {\n    const last = res[res.length - 1];\n    const cur = intervals[i];\n    if (cur[0] <= last[1]) {\n      last[1] = Math.max(last[1], cur[1]);\n    } else {\n      res.push(cur);\n    }\n  }\n  return res;\n}\n// Time: O(n log n), Space: O(n)",
    "tags": ["arrays", "intervals", "sorting"]
  },
  {
    "id": 54,
    "category": "Arrays",
    "difficulty": "Medium",
    "question": "Find the majority element (> n/2 times).",
    "answer": "function majorityElement(nums) {\n  let count = 0, candidate = null;\n  for (let n of nums) {\n    if (count === 0) candidate = n;\n    count += (n === candidate) ? 1 : -1;\n  }\n  return candidate;\n}\n// Time: O(n), Space: O(1)",
    "tags": ["arrays", "boyer-moore", "voting"]
  },
  {
    "id": 55,
    "category": "Arrays",
    "difficulty": "Medium",
    "question": "Find the median of two sorted arrays (simple merge approach).",
    "answer": "function findMedianSortedArrays(nums1, nums2) {\n  const merged = [];\n  let i = 0, j = 0;\n  while (i < nums1.length && j < nums2.length) {\n    if (nums1[i] < nums2[j]) merged.push(nums1[i++]);\n    else merged.push(nums2[j++]);\n  }\n  while (i < nums1.length) merged.push(nums1[i++]);\n  while (j < nums2.length) merged.push(nums2[j++]);\n  const n = merged.length;\n  if (n % 2 === 1) return merged[Math.floor(n / 2)];\n  return (merged[n / 2 - 1] + merged[n / 2]) / 2;\n}\n// Time: O(m + n), Space: O(m + n)",
    "tags": ["arrays", "sorting", "median"]
  },
  {
    "id": 56,
    "category": "Sliding Window",
    "difficulty": "Medium",
    "question": "Find maximum sum subarray of size k.",
    "answer": "function maxSumSubarrayOfSizeK(nums, k) {\n  let windowSum = 0;\n  let maxSum = -Infinity;\n  for (let i = 0; i < nums.length; i++) {\n    windowSum += nums[i];\n    if (i >= k - 1) {\n      maxSum = Math.max(maxSum, windowSum);\n      windowSum -= nums[i - k + 1];\n    }\n  }\n  return maxSum;\n}\n// Time: O(n), Space: O(1)",
    "tags": ["arrays", "sliding-window"]
  },
  {
    "id": 57,
    "category": "Sliding Window",
    "difficulty": "Medium",
    "question": "Minimum window substring containing all characters of another string.",
    "answer": "function minWindow(s, t) {\n  if (t.length === 0) return \"\";\n  const need = {};\n  for (let ch of t) need[ch] = (need[ch] || 0) + 1;\n  let have = 0, required = Object.keys(need).length;\n  let left = 0, resLen = Infinity, res = [-1, -1];\n  const window = {};\n  for (let right = 0; right < s.length; right++) {\n    const c = s[right];\n    window[c] = (window[c] || 0) + 1;\n    if (need[c] && window[c] === need[c]) have++;\n    while (have === required) {\n      if (right - left + 1 < resLen) {\n        resLen = right - left + 1;\n        res = [left, right];\n      }\n      const lc = s[left];\n      window[lc]--;\n      if (need[lc] && window[lc] < need[lc]) have--;\n      left++;\n    }\n  }\n  return resLen === Infinity ? \"\" : s.slice(res[0], res[1] + 1);\n}\n// Time: O(n), Space: O(1) approx",
    "tags": ["strings", "sliding-window", "hash-map"]
  },
  {
    "id": 58,
    "category": "Strings",
    "difficulty": "Medium",
    "question": "Longest palindromic substring.",
    "answer": "function longestPalindrome(s) {\n  if (s.length < 2) return s;\n  let start = 0, end = 0;\n  function expand(l, r) {\n    while (l >= 0 && r < s.length && s[l] === s[r]) {\n      l--; r++;\n    }\n    return [l + 1, r - 1];\n  }\n  for (let i = 0; i < s.length; i++) {\n    let [l1, r1] = expand(i, i);\n    let [l2, r2] = expand(i, i + 1);\n    if (r1 - l1 > end - start) { start = l1; end = r1; }\n    if (r2 - l2 > end - start) { start = l2; end = r2; }\n  }\n  return s.slice(start, end + 1);\n}\n// Time: O(n^2), Space: O(1)",
    "tags": ["strings", "palindrome", "two-pointers"]
  },
  {
    "id": 59,
    "category": "Strings",
    "difficulty": "Medium",
    "question": "Group anagrams together.",
    "answer": "function groupAnagrams(strs) {\n  const map = new Map();\n  for (let s of strs) {\n    const key = s.split('').sort().join('');\n    if (!map.has(key)) map.set(key, []);\n    map.get(key).push(s);\n  }\n  return Array.from(map.values());\n}\n// Time: O(n k log k), Space: O(nk)",
    "tags": ["strings", "hash-map", "anagram"]
  },
  {
    "id": 60,
    "category": "Strings",
    "difficulty": "Medium",
    "question": "Implement basic string strStr (substring search) using sliding window.",
    "answer": "function strStr(haystack, needle) {\n  if (needle === \"\") return 0;\n  const n = haystack.length, m = needle.length;\n  for (let i = 0; i + m <= n; i++) {\n    let j = 0;\n    while (j < m && haystack[i + j] === needle[j]) j++;\n    if (j === m) return i;\n  }\n  return -1;\n}\n// Time: O((n-m+1) * m), Space: O(1)",
    "tags": ["strings", "search"]
  },
  {
    "id": 61,
    "category": "Hashing",
    "difficulty": "Easy",
    "question": "Find the first repeated element in an array.",
    "answer": "function firstRepeated(nums) {\n  const seen = new Set();\n  for (let x of nums) {\n    if (seen.has(x)) return x;\n    seen.add(x);\n  }\n  return null;\n}\n// Time: O(n), Space: O(n)",
    "tags": ["hash-set", "arrays"]
  },
  {
    "id": 62,
    "category": "Hashing",
    "difficulty": "Medium",
    "question": "Subarray sum equals k (count number of subarrays).",
    "answer": "function subarraySum(nums, k) {\n  const map = new Map();\n  map.set(0, 1);\n  let sum = 0, count = 0;\n  for (let n of nums) {\n    sum += n;\n    if (map.has(sum - k)) count += map.get(sum - k);\n    map.set(sum, (map.get(sum) || 0) + 1);\n  }\n  return count;\n}\n// Time: O(n), Space: O(n)",
    "tags": ["arrays", "prefix-sum", "hash-map"]
  },
  {
    "id": 63,
    "category": "Linked Lists",
    "difficulty": "Medium",
    "question": "Partition a linked list around value x while preserving relative order.",
    "answer": "function partition(head, x) {\n  const beforeHead = { val: 0, next: null };\n  const afterHead = { val: 0, next: null };\n  let before = beforeHead, after = afterHead;\n  let cur = head;\n  while (cur) {\n    if (cur.val < x) {\n      before.next = cur;\n      before = before.next;\n    } else {\n      after.next = cur;\n      after = after.next;\n    }\n    cur = cur.next;\n  }\n  after.next = null;\n  before.next = afterHead.next;\n  return beforeHead.next;\n}\n// Time: O(n), Space: O(1)",
    "tags": ["linked-list", "partition"]
  },
  {
    "id": 64,
    "category": "Linked Lists",
    "difficulty": "Hard",
    "question": "Reorder list: L0→L1→…→Ln to L0→Ln→L1→Ln-1→…",
    "answer": "function reorderList(head) {\n  if (!head || !head.next) return head;\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  let prev = null, cur = slow.next;\n  slow.next = null;\n  while (cur) {\n    const next = cur.next;\n    cur.next = prev;\n    prev = cur;\n    cur = next;\n  }\n  let first = head, second = prev;\n  while (second) {\n    const t1 = first.next;\n    const t2 = second.next;\n    first.next = second;\n    second.next = t1;\n    first = t1;\n    second = t2;\n  }\n  return head;\n}\n// Time: O(n), Space: O(1)",
    "tags": ["linked-list", "rearrangement"]
  },
  {
    "id": 65,
    "category": "Stacks",
    "difficulty": "Medium",
    "question": "Largest rectangle in a histogram.",
    "answer": "function largestRectangleArea(heights) {\n  const stack = [];\n  let maxArea = 0;\n  heights.push(0);\n  for (let i = 0; i < heights.length; i++) {\n    while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {\n      const h = heights[stack.pop()];\n      const width = stack.length ? i - stack[stack.length - 1] - 1 : i;\n      maxArea = Math.max(maxArea, h * width);\n    }\n    stack.push(i);\n  }\n  heights.pop();\n  return maxArea;\n}\n// Time: O(n), Space: O(n)",
    "tags": ["stack", "monotonic-stack", "histogram"]
  },
  {
    "id": 66,
    "category": "Stacks",
    "difficulty": "Medium",
    "question": "Next greater element for each array element.",
    "answer": "function nextGreaterElements(nums) {\n  const res = new Array(nums.length).fill(-1);\n  const stack = [];\n  for (let i = 0; i < nums.length; i++) {\n    while (stack.length && nums[i] > nums[stack[stack.length - 1]]) {\n      const idx = stack.pop();\n      res[idx] = nums[i];\n    }\n    stack.push(i);\n  }\n  return res;\n}\n// Time: O(n), Space: O(n)",
    "tags": ["stack", "monotonic-stack"]
  },
  {
    "id": 67,
    "category": "Queues",
    "difficulty": "Medium",
    "question": "Sliding window maximum using deque.",
    "answer": "function maxSlidingWindow(nums, k) {\n  const deque = [];\n  const res = [];\n  for (let i = 0; i < nums.length; i++) {\n    while (deque.length && deque[0] <= i - k) deque.shift();\n    while (deque.length && nums[deque[deque.length - 1]] <= nums[i]) deque.pop();\n    deque.push(i);\n    if (i >= k - 1) res.push(nums[deque[0]]);\n  }\n  return res;\n}\n// Time: O(n), Space: O(k)",
    "tags": ["deque", "sliding-window", "max"]
  },
  {
    "id": 68,
    "category": "Heaps",
    "difficulty": "Medium",
    "question": "Merge k sorted linked lists using a min-heap.",
    "answer": "function mergeKLists(lists) {\n  const heap = [];\n  function push(node) {\n    if (!node) return;\n    heap.push(node);\n    let i = heap.length - 1;\n    while (i > 0) {\n      const p = (i - 1) >> 1;\n      if (heap[p].val <= heap[i].val) break;\n      [heap[p], heap[i]] = [heap[i], heap[p]];\n      i = p;\n    }\n  }\n  function pop() {\n    if (!heap.length) return null;\n    const top = heap[0];\n    const last = heap.pop();\n    if (heap.length) {\n      heap[0] = last;\n      let i = 0;\n      while (true) {\n        let l = 2 * i + 1, r = 2 * i + 2, s = i;\n        if (l < heap.length && heap[l].val < heap[s].val) s = l;\n        if (r < heap.length && heap[r].val < heap[s].val) s = r;\n        if (s === i) break;\n        [heap[i], heap[s]] = [heap[s], heap[i]];\n        i = s;\n      }\n    }\n    return top;\n  }\n  for (let node of lists) push(node);\n  const dummy = { val: 0, next: null };\n  let cur = dummy;\n  while (heap.length) {\n    const node = pop();\n    cur.next = node;\n    cur = cur.next;\n    if (node.next) push(node.next);\n  }\n  return dummy.next;\n}\n// Time: O(N log k), Space: O(k)",
    "tags": ["heap", "linked-list", "merge"]
  },
  {
    "id": 69,
    "category": "Heaps",
    "difficulty": "Medium",
    "question": "Top K frequent elements in an array.",
    "answer": "function topKFrequent(nums, k) {\n  const freq = new Map();\n  for (let n of nums) freq.set(n, (freq.get(n) || 0) + 1);\n  const buckets = Array(nums.length + 1).fill(0).map(() => []);\n  for (let [num, f] of freq.entries()) {\n    buckets[f].push(num);\n  }\n  const res = [];\n  for (let i = buckets.length - 1; i >= 0 && res.length < k; i--) {\n    for (let num of buckets[i]) {\n      res.push(num);\n      if (res.length === k) break;\n    }\n  }\n  return res;\n}\n// Time: O(n), Space: O(n)",
    "tags": ["hash-map", "bucket-sort", "heap-like"]
  },
  {
    "id": 70,
    "category": "Graphs",
    "difficulty": "Medium",
    "question": "Number of islands in a 2D grid (DFS/BFS).",
    "answer": "function numIslands(grid) {\n  if (!grid.length) return 0;\n  const rows = grid.length, cols = grid[0].length;\n  let count = 0;\n  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];\n  function dfs(r, c) {\n    if (r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] !== '1') return;\n    grid[r][c] = '0';\n    for (let [dr, dc] of dirs) dfs(r + dr, c + dc);\n  }\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === '1') {\n        count++;\n        dfs(r, c);\n      }\n    }\n  }\n  return count;\n}\n// Time: O(R*C), Space: O(R*C) worst",
    "tags": ["graphs", "dfs", "grid"]
  },
  {
    "id": 71,
    "category": "Graphs",
    "difficulty": "Medium",
    "question": "Clone an undirected graph using DFS.",
    "answer": "function cloneGraph(node) {\n  if (!node) return null;\n  const map = new Map();\n  function dfs(n) {\n    if (map.has(n)) return map.get(n);\n    const copy = { val: n.val, neighbors: [] };\n    map.set(n, copy);\n    for (let nei of n.neighbors) {\n      copy.neighbors.push(dfs(nei));\n    }\n    return copy;\n  }\n  return dfs(node);\n}\n// Time: O(V + E), Space: O(V)",
    "tags": ["graphs", "dfs", "copy"]
  },
  {
    "id": 72,
    "category": "Graphs",
    "difficulty": "Medium",
    "question": "Course schedule: detect if all courses can be finished (topological sort).",
    "answer": "function canFinish(numCourses, prerequisites) {\n  const graph = Array.from({ length: numCourses }, () => []);\n  const indeg = new Array(numCourses).fill(0);\n  for (let [a, b] of prerequisites) {\n    graph[b].push(a);\n    indeg[a]++;\n  }\n  const queue = [];\n  for (let i = 0; i < numCourses; i++) if (indeg[i] === 0) queue.push(i);\n  let visited = 0;\n  while (queue.length) {\n    const u = queue.shift();\n    visited++;\n    for (let v of graph[u]) {\n      if (--indeg[v] === 0) queue.push(v);\n    }\n  }\n  return visited === numCourses;\n}\n// Time: O(V + E), Space: O(V + E)",
    "tags": ["graphs", "topological-sort", "bfs"]
  },
  {
    "id": 73,
    "category": "Graphs",
    "difficulty": "Hard",
    "question": "Shortest path in weighted graph using Dijkstra (adjacency list).",
    "answer": "function dijkstra(n, edges, src) {\n  const graph = Array.from({ length: n }, () => []);\n  for (let [u, v, w] of edges) {\n    graph[u].push([v, w]);\n    graph[v].push([u, w]);\n  }\n  const dist = new Array(n).fill(Infinity);\n  dist[src] = 0;\n  const visited = new Array(n).fill(false);\n  // simple O(n^2) implementation without priority queue\n  for (let i = 0; i < n; i++) {\n    let u = -1;\n    for (let j = 0; j < n; j++) {\n      if (!visited[j] && (u === -1 || dist[j] < dist[u])) u = j;\n    }\n    if (dist[u] === Infinity) break;\n    visited[u] = true;\n    for (let [v, w] of graph[u]) {\n      if (dist[u] + w < dist[v]) dist[v] = dist[u] + w;\n    }\n  }\n  return dist;\n}\n// Time: O(n^2 + m), Space: O(n + m)",
    "tags": ["graphs", "shortest-path", "dijkstra"]
  },
  {
    "id": 74,
    "category": "Union-Find",
    "difficulty": "Medium",
    "question": "Implement Disjoint Set Union (Union-Find) with path compression and union by rank.",
    "answer": "class UnionFind {\n  constructor(n) {\n    this.parent = Array.from({ length: n }, (_, i) => i);\n    this.rank = new Array(n).fill(0);\n  }\n  find(x) {\n    if (this.parent[x] !== x) this.parent[x] = this.find(this.parent[x]);\n    return this.parent[x];\n  }\n  union(x, y) {\n    let rx = this.find(x), ry = this.find(y);\n    if (rx === ry) return false;\n    if (this.rank[rx] < this.rank[ry]) [rx, ry] = [ry, rx];\n    this.parent[ry] = rx;\n    if (this.rank[rx] === this.rank[ry]) this.rank[rx]++;\n    return true;\n  }\n}\n// Find: Amortized O(α(n)), Space: O(n)",
    "tags": ["union-find", "disjoint-set"]
  },
  {
    "id": 75,
    "category": "Dynamic Programming",
    "difficulty": "Easy",
    "question": "Climbing stairs: count ways to reach the top taking 1 or 2 steps.",
    "answer": "function climbStairs(n) {\n  if (n <= 2) return n;\n  let a = 1, b = 2;\n  for (let i = 3; i <= n; i++) {\n    const c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}\n// Time: O(n), Space: O(1)",
    "tags": ["dp", "fibonacci"]
  },
  {
    "id": 76,
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "question": "Coin change: minimum coins to make a given amount.",
    "answer": "function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let c of coins) {\n    for (let a = c; a <= amount; a++) {\n      dp[a] = Math.min(dp[a], dp[a - c] + 1);\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\n// Time: O(amount * coins), Space: O(amount)",
    "tags": ["dp", "unbounded-knapsack"]
  },
  {
    "id": 77,
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "question": "Longest increasing subsequence length.",
    "answer": "function lengthOfLIS(nums) {\n  const tails = [];\n  for (let x of nums) {\n    let l = 0, r = tails.length;\n    while (l < r) {\n      const m = (l + r) >> 1;\n      if (tails[m] < x) l = m + 1;\n      else r = m;\n    }\n    tails[l] = x;\n  }\n  return tails.length;\n}\n// Time: O(n log n), Space: O(n)",
    "tags": ["dp", "binary-search", "lis"]
  },
  {
    "id": 78,
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "question": "Longest common subsequence of two strings.",
    "answer": "function longestCommonSubsequence(text1, text2) {\n  const n = text1.length, m = text2.length;\n  const dp = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(0));\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      if (text1[i - 1] === text2[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1];\n      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n    }\n  }\n  return dp[n][m];\n}\n// Time: O(nm), Space: O(nm)",
    "tags": ["dp", "lcs", "strings"]
  },
  {
    "id": 79,
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "question": "House Robber: max sum of non-adjacent houses.",
    "answer": "function rob(nums) {\n  let incl = 0, excl = 0;\n  for (let n of nums) {\n    const newIncl = excl + n;\n    excl = Math.max(excl, incl);\n    incl = newIncl;\n  }\n  return Math.max(incl, excl);\n}\n// Time: O(n), Space: O(1)",
    "tags": ["dp", "1d"]
  },
  {
    "id": 80,
    "category": "Backtracking",
    "difficulty": "Medium",
    "question": "Generate all subsets (power set) of an array.",
    "answer": "function subsets(nums) {\n  const res = [];\n  function backtrack(start, path) {\n    res.push([...path]);\n    for (let i = start; i < nums.length; i++) {\n      path.push(nums[i]);\n      backtrack(i + 1, path);\n      path.pop();\n    }\n  }\n  backtrack(0, []);\n  return res;\n}\n// Time: O(2^n), Space: O(2^n)",
    "tags": ["backtracking", "subsets"]
  },
  {
    "id": 81,
    "category": "Backtracking",
    "difficulty": "Medium",
    "question": "Combination sum: find combinations that sum to target (unlimited use of numbers).",
    "answer": "function combinationSum(candidates, target) {\n  candidates.sort((a, b) => a - b);\n  const res = [];\n  function backtrack(start, remain, path) {\n    if (remain === 0) {\n      res.push([...path]);\n      return;\n    }\n    for (let i = start; i < candidates.length; i++) {\n      const val = candidates[i];\n      if (val > remain) break;\n      path.push(val);\n      backtrack(i, remain - val, path);\n      path.pop();\n    }\n  }\n  backtrack(0, target, []);\n  return res;\n}\n// Time: O(2^n) worst, Space: O(target)",
    "tags": ["backtracking", "combination-sum"]
  },
  {
    "id": 82,
    "category": "Backtracking",
    "difficulty": "Hard",
    "question": "N-Queens: return all distinct solutions.",
    "answer": "function solveNQueens(n) {\n  const res = [];\n  const cols = new Set();\n  const diag1 = new Set();\n  const diag2 = new Set();\n  const board = Array.from({ length: n }, () => new Array(n).fill('.'));\n  function backtrack(r) {\n    if (r === n) {\n      res.push(board.map(row => row.join('')));\n      return;\n    }\n    for (let c = 0; c < n; c++) {\n      if (cols.has(c) || diag1.has(r - c) || diag2.has(r + c)) continue;\n      cols.add(c); diag1.add(r - c); diag2.add(r + c);\n      board[r][c] = 'Q';\n      backtrack(r + 1);\n      board[r][c] = '.';\n      cols.delete(c); diag1.delete(r - c); diag2.delete(r + c);\n    }\n  }\n  backtrack(0);\n  return res;\n}\n// Time: O(n!), Space: O(n^2)",
    "tags": ["backtracking", "n-queens"]
  },
  {
    "id": 83,
    "category": "Trees",
    "difficulty": "Medium",
    "question": "Path sum: check if a root-to-leaf path equals a target sum.",
    "answer": "function hasPathSum(root, targetSum) {\n  if (!root) return false;\n  if (!root.left && !root.right) return root.val === targetSum;\n  return hasPathSum(root.left, targetSum - root.val) ||\n         hasPathSum(root.right, targetSum - root.val);\n}\n// Time: O(n), Space: O(h)",
    "tags": ["trees", "dfs", "recursion"]
  },
  {
    "id": 84,
    "category": "Trees",
    "difficulty": "Medium",
    "question": "Right side view of a binary tree.",
    "answer": "function rightSideView(root) {\n  if (!root) return [];\n  const res = [];\n  const queue = [root];\n  while (queue.length) {\n    const size = queue.length;\n    for (let i = 0; i < size; i++) {\n      const node = queue.shift();\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n      if (i === size - 1) res.push(node.val);\n    }\n  }\n  return res;\n}\n// Time: O(n), Space: O(n)",
    "tags": ["trees", "bfs", "view"]
  },
  {
    "id": 85,
    "category": "Trees",
    "difficulty": "Medium",
    "question": "Flatten binary tree to linked list in-place (preorder).",
    "answer": "function flatten(root) {\n  let prev = null;\n  function dfs(node) {\n    if (!node) return;\n    dfs(node.right);\n    dfs(node.left);\n    node.right = prev;\n    node.left = null;\n    prev = node;\n  }\n  dfs(root);\n}\n// Time: O(n), Space: O(h)",
    "tags": ["trees", "recursion", "flatten"]
  },
  {
    "id": 86,
    "category": "Trees",
    "difficulty": "Medium",
    "question": "Populate next right pointers in each node of a perfect binary tree.",
    "answer": "function connect(root) {\n  if (!root) return null;\n  let leftmost = root;\n  while (leftmost.left) {\n    let head = leftmost;\n    while (head) {\n      head.left.next = head.right;\n      if (head.next) head.right.next = head.next.left;\n      head = head.next;\n    }\n    leftmost = leftmost.left;\n  }\n  return root;\n}\n// Time: O(n), Space: O(1)",
    "tags": ["trees", "linked-list", "bfs-like"]
  },
  {
    "id": 87,
    "category": "Bit Manipulation",
    "difficulty": "Easy",
    "question": "Find the single element in an array where every other appears twice.",
    "answer": "function singleNumber(nums) {\n  let res = 0;\n  for (let n of nums) res ^= n;\n  return res;\n}\n// Time: O(n), Space: O(1)",
    "tags": ["bit-manipulation", "xor"]
  },
  {
    "id": 88,
    "category": "Bit Manipulation",
    "difficulty": "Medium",
    "question": "Count number of set bits in an integer.",
    "answer": "function hammingWeight(n) {\n  let count = 0;\n  while (n !== 0) {\n    n &= (n - 1);\n    count++;\n  }\n  return count;\n}\n// Time: O(k) where k is set bits, Space: O(1)",
    "tags": ["bit-manipulation", "count-bits"]
  },
  {
    "id": 89,
    "category": "Bit Manipulation",
    "difficulty": "Medium",
    "question": "Reverse bits of a 32-bit unsigned integer.",
    "answer": "function reverseBits(n) {\n  let res = 0;\n  for (let i = 0; i < 32; i++) {\n    res = (res << 1) | (n & 1);\n    n >>>= 1;\n  }\n  return res >>> 0;\n}\n// Time: O(1), Space: O(1)",
    "tags": ["bit-manipulation"]
  },
  {
    "id": 90,
    "category": "Math",
    "difficulty": "Easy",
    "question": "Check if a number is a power of two.",
    "answer": "function isPowerOfTwo(n) {\n  if (n <= 0) return false;\n  return (n & (n - 1)) === 0;\n}\n// Time: O(1), Space: O(1)",
    "tags": ["math", "bit-manipulation"]
  },
  {
    "id": 91,
    "category": "Math",
    "difficulty": "Easy",
    "question": "Compute integer square root using binary search.",
    "answer": "function mySqrt(x) {\n  if (x < 2) return x;\n  let left = 1, right = Math.floor(x / 2), ans = 1;\n  while (left <= right) {\n    const mid = left + ((right - left) >> 1);\n    if (mid * mid <= x) {\n      ans = mid;\n      left = mid + 1;\n    } else right = mid - 1;\n  }\n  return ans;\n}\n// Time: O(log x), Space: O(1)",
    "tags": ["math", "binary-search"]
  },
  {
    "id": 92,
    "category": "Searching",
    "difficulty": "Medium",
    "question": "Search in rotated sorted array without duplicates.",
    "answer": "function searchRotated(nums, target) {\n  let l = 0, r = nums.length - 1;\n  while (l <= r) {\n    const m = (l + r) >> 1;\n    if (nums[m] === target) return m;\n    if (nums[l] <= nums[m]) {\n      if (nums[l] <= target && target < nums[m]) r = m - 1;\n      else l = m + 1;\n    } else {\n      if (nums[m] < target && target <= nums[r]) l = m + 1;\n      else r = m - 1;\n    }\n  }\n  return -1;\n}\n// Time: O(log n), Space: O(1)",
    "tags": ["arrays", "binary-search"]
  },
  {
    "id": 93,
    "category": "Sorting",
    "difficulty": "Medium",
    "question": "Implement quicksort for an array.",
    "answer": "function quickSort(arr, l = 0, r = arr.length - 1) {\n  if (l >= r) return;\n  const pivot = arr[r];\n  let i = l;\n  for (let j = l; j < r; j++) {\n    if (arr[j] < pivot) {\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n      i++;\n    }\n  }\n  [arr[i], arr[r]] = [arr[r], arr[i]];\n  quickSort(arr, l, i - 1);\n  quickSort(arr, i + 1, r);\n}\n// Avg Time: O(n log n), Space: O(log n)",
    "tags": ["sorting", "quick-sort"]
  },
  {
    "id": 94,
    "category": "Design",
    "difficulty": "Medium",
    "question": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
    "answer": "class MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n  push(x) {\n    this.stack.push(x);\n    const min = this.minStack.length === 0 ? x : Math.min(x, this.minStack[this.minStack.length - 1]);\n    this.minStack.push(min);\n  }\n  pop() {\n    this.stack.pop();\n    this.minStack.pop();\n  }\n  top() {\n    return this.stack[this.stack.length - 1];\n  }\n  getMin() {\n    return this.minStack[this.minStack.length - 1];\n  }\n}\n// Time: O(1) per operation, Space: O(n)",
    "tags": ["stack", "design"]
  },
  {
    "id": 95,
    "category": "Design",
    "difficulty": "Medium",
    "question": "Design an LRU cache with get and put in O(1).",
    "answer": "class LRUCache {\n  constructor(capacity) {\n    this.cap = capacity;\n    this.map = new Map();\n  }\n  get(key) {\n    if (!this.map.has(key)) return -1;\n    const val = this.map.get(key);\n    this.map.delete(key);\n    this.map.set(key, val);\n    return val;\n  }\n  put(key, value) {\n    if (this.map.has(key)) this.map.delete(key);\n    this.map.set(key, value);\n    if (this.map.size > this.cap) {\n      const firstKey = this.map.keys().next().value;\n      this.map.delete(firstKey);\n    }\n  }\n}\n// Time: O(1) per op, Space: O(capacity)",
    "tags": ["design", "hash-map", "linked-list-like"]
  },
  {
    "id": 96,
    "category": "Greedy",
    "difficulty": "Medium",
    "question": "Activity selection: maximum number of non-overlapping intervals.",
    "answer": "function maxNonOverlappingIntervals(intervals) {\n  intervals.sort((a, b) => a[1] - b[1]);\n  let count = 0, end = -Infinity;\n  for (let [s, e] of intervals) {\n    if (s >= end) {\n      count++;\n      end = e;\n    }\n  }\n  return count;\n}\n// Time: O(n log n), Space: O(1)",
    "tags": ["greedy", "intervals"]
  },
  {
    "id": 97,
    "category": "Greedy",
    "difficulty": "Medium",
    "question": "Minimum number of coins to make change using greedy (assuming canonical coin system).",
    "answer": "function minCoinsGreedy(coins, amount) {\n  coins.sort((a, b) => b - a);\n  let count = 0;\n  for (let c of coins) {\n    if (amount === 0) break;\n    const use = Math.floor(amount / c);\n    count += use;\n    amount -= use * c;\n  }\n  return amount === 0 ? count : -1;\n}\n// Time: O(n log n), Space: O(1)",
    "tags": ["greedy", "coin-change"]
  },
  {
    "id": 98,
    "category": "Matrix",
    "difficulty": "Medium",
    "question": "Rotate an n x n matrix by 90 degrees in place.",
    "answer": "function rotateMatrix(matrix) {\n  const n = matrix.length;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    matrix[i].reverse();\n  }\n  return matrix;\n}\n// Time: O(n^2), Space: O(1)",
    "tags": ["matrix", "in-place"]
  },
  {
    "id": 99,
    "category": "Matrix",
    "difficulty": "Medium",
    "question": "Set matrix zeroes: if an element is 0, set its row and column to 0 in place.",
    "answer": "function setZeroes(matrix) {\n  const m = matrix.length, n = matrix[0].length;\n  let firstRowZero = false, firstColZero = false;\n  for (let i = 0; i < m; i++) if (matrix[i][0] === 0) firstColZero = true;\n  for (let j = 0; j < n; j++) if (matrix[0][j] === 0) firstRowZero = true;\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (matrix[i][j] === 0) {\n        matrix[i][0] = 0;\n        matrix[0][j] = 0;\n      }\n    }\n  }\n  for (let i = 1; i < m; i++) {\n    if (matrix[i][0] === 0) {\n      for (let j = 1; j < n; j++) matrix[i][j] = 0;\n    }\n  }\n  for (let j = 1; j < n; j++) {\n    if (matrix[0][j] === 0) {\n      for (let i = 1; i < m; i++) matrix[i][j] = 0;\n    }\n  }\n  if (firstRowZero) for (let j = 0; j < n; j++) matrix[0][j] = 0;\n  if (firstColZero) for (let i = 0; i < m; i++) matrix[i][0] = 0;\n  return matrix;\n}\n// Time: O(mn), Space: O(1)",
    "tags": ["matrix", "in-place", "flags"]
  },
  {
    "id": 100,
    "category": "Matrix",
    "difficulty": "Medium",
    "question": "Spiral order traversal of a matrix.",
    "answer": "function spiralOrder(matrix) {\n  if (!matrix.length) return [];\n  let top = 0, bottom = matrix.length - 1;\n  let left = 0, right = matrix[0].length - 1;\n  const res = [];\n  while (top <= bottom && left <= right) {\n    for (let j = left; j <= right; j++) res.push(matrix[top][j]);\n    top++;\n    for (let i = top; i <= bottom; i++) res.push(matrix[i][right]);\n    right--;\n    if (top <= bottom) {\n      for (let j = right; j >= left; j--) res.push(matrix[bottom][j]);\n      bottom--;\n    }\n    if (left <= right) {\n      for (let i = bottom; i >= top; i--) res.push(matrix[i][left]);\n      left++;\n    }\n  }\n  return res;\n}\n// Time: O(mn), Space: O(1) extra",
    "tags": ["matrix", "simulation"]
  }
  ]}